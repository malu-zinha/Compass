## API - Compass

Este documento descreve a API backend para a plataforma Compass: endpoints REST, contratos de request/response, comportamento assíncrono e o protocolo em tempo real usado pela extensão para sugestões durante chamadas.

Autenticação
- Método: JWT Bearer token
- Enviar header: `Authorization: Bearer <TOKEN>`
- Tokens são obtidos via endpoint de login do site; a extensão armazena o token em `chrome.storage` e usa em requisições ao backend.

Formato de erros
- Código HTTP + corpo JSON padrão:

{
  "error": true,
  "message": "Descrição legível do erro",
  "code": "ERROR_CODE",  // ex: INVALID_AUTH, NOT_FOUND, VALIDATION_ERROR
  "details": {...} // opcional
}

----

1) Health

- GET /api/health
  - Descrição: checagem simples de disponibilidade.
  - Autenticação: none
  - Resposta 200:
    { "status": "ok", "uptime": 12345 }

----

2) Autenticação (exemplo mínimo)

- POST /api/auth/login
  - Descrição: autentica usuário e retorna JWT.
  - Body:
    { "email": "user@example.com", "password": "senha" }
  - Resposta 200:
    { "token": "<jwt>", "user": { "id": "u1", "name": "Nome" } }

- POST /api/auth/refresh
  - Body: { "refreshToken": "..." }

----

3) Interviews / Templates

- POST /api/interviews
  - Cria um novo interview record (modelo + metadados).
  - Autenticação: required
  - Body:
    {
      "title": "Entrevista Senior Backend",
      "role": "Backend Engineer",
      "questions": [{ "id": "q1", "text": "Fale sobre ...", "type": "behavioral" }],
      "required_competencies": ["comunicacao", "arquitetura"],
      "description_profile_ideal": "Texto livre"
    }
  - Resposta 201:
    { "id": "interview_123", "created_at": "ISO8601" }

- GET /api/interviews/:id
  - Recupera metadados do interview, listas de áudios/summary associadas.

- GET /api/interviews
  - Lista entrevistas do usuário/organização (paginado).

- DELETE /api/interviews/:id
  - Remove entrevista (ou marca como arquivada).

----

4) Upload de áudio e metadados

- POST /api/interviews/:id/audio
  - Upload do arquivo de áudio (multipart/form-data) ou envio de `audio_url` se já hospedado.
  - Campos multipart:
    - file: blob de áudio (webm, mp3, wav)
    - metadata: JSON string com { "candidate": {"name","id"}, "recorded_at": "ISO8601" }
  - Resposta 202 (aceite para processamento):
    { "audio_id": "audio_456", "status": "uploaded", "processing_job": "job_789" }
  - Observações: o servidor deve armazenar o arquivo em object storage e enfileirar job de transcrição.

----

5) Transcrição (STT)

- POST /api/interviews/:id/transcribe
  - Inicia (ou solicita reprocessamento) da transcrição de um áudio associado.
  - Body: { "audio_id": "audio_456", "language": "pt-BR", "mode": "batch|realtime" }
  - Resposta 202: { "job": "job_123", "status": "queued" }

- GET /api/interviews/:id/transcription/:transcription_id
  - Obtém a transcrição quando pronta.
  - Resposta 200:
    {
      "id": "t1",
      "audio_id": "audio_456",
      "text": "texto completo...",
      "segments": [ { "start": 0, "end": 5.4, "speaker": "interviewee", "text": "..." } ]
    }

----

6) Geração de resumo padronizado (IA)

- POST /api/interviews/:id/summarize
  - Solicita ao serviço de IA a geração do `Summary` a partir de uma transcrição.
  - Body:
    {
      "transcription_id": "t1",
      "model": "default", // opcional
      "options": { "include_behavioural_analysis": true }
    }
  - Comportamento: operação assíncrona. Retorna 202 com job id.
  - Resposta 202:
    { "job": "job_summary_1", "status": "queued" }

- GET /api/interviews/:id/summary/:summary_id
  - Recupera o resumo após a conclusão.
  - Resposta 200 (exemplo):
    {
      "id": "s1",
      "interview_id": "interview_123",
      "questions": [ { "question_id": "q1", "question_text": "...", "answer_text": "...", "highlights": ["..."] } ],
      "pros": ["..."],
      "cons": ["..."],
      "competencies": [ { "name": "comunicacao", "score": 0.8 } ],
      "suggested_questions": [ { "text": "...", "reason": "..." } ],
      "generated_at": "ISO8601"
    }

----

7) Profiles (Perfil ideal)

- POST /api/profiles
  - Cria perfil ideal (texto e metadados).
  - Body: { "title": "Senior BE", "description": "..." }

- GET /api/profiles/:id
- GET /api/profiles
- PUT /api/profiles/:id
- DELETE /api/profiles/:id

----

8) Ranking / análise de compatibilidade

- GET /api/candidates/:candidateId/ranking?profileId=:profileId
  - Calcula/retorna score do candidato contra um `Profile`.
  - Resposta:
    { "candidateId": "c1", "profileId": "p1", "score": 0.83, "breakdown": { "comunicacao": 0.9, "lideranca": 0.6 } }

- GET /api/interviews/:id/ranking
  - Retorna ranking dos candidatos associados a uma entrevista/template.

----

9) WebSocket / Real-time protocol (para extensão)

- Endpoint: `wss://{HOST}/realtime` (ou /ws)
- Autenticação: enviar token JWT no protocolo de abertura (`Sec-WebSocket-Protocol: bearer,<token>`) ou imediatamente após abrir enviar uma mensagem `auth`.

Protocolo (JSON messages) — exemplo mínimo:

1) Autenticação
{ "type": "auth", "token": "<jwt>" }

Resposta: { "type": "auth_ack", "status": "ok" }

2) Enviar chunk de áudio (base64 ou binary opcional)
{ "type": "audio_chunk", "interviewId": "interview_123", "audioId": "audio_456", "seq": 1, "chunk": "<base64>", "sampleRate": 48000 }

Servidor responde com ack:
{ "type": "chunk_ack", "seq": 1 }

3) Solicitar sugestão rápida (pode incluir transcrição parcial)
{ "type": "suggest", "interviewId": "interview_123", "context": "texto ou transcription snippet" }

Servidor retorna sugestões:
{ "type": "suggestion", "suggestions": [ { "text": "Pergunta X?", "reason": "clarificar responsabilidade" } ] }

4) Finalizar sessão / request processing
{ "type": "end_session", "interviewId": "interview_123" }

Observações: usar compressão e batching para reduzir latência/custos; prefer enviar transcrições parciais ao invés de áudio binário quando possível (menos CPU no backend). Definir TTL para sessões e aceitar reconexões com resume tokens.

----

10) Webhooks / Callbacks

- POST /api/webhooks/summary-completed
  - O backend pode notificar o site/terceiros quando o summary estiver pronto.
  - Payload: o objeto `Summary` resumido ou apenas IDs + status (configurável).

----

11) Arquivos e formatos suportados
- Áudio: webm, wav, mp3
- Transmissão em tempo real: PCM/opus encoded ou envio de transcrição parcial (texto)

----

12) Observações operacionais

- Jobs de transcrição e summary devem ser enfileirados (RabbitMQ/SQS/Redis Streams). Retornar 202 quando processado assincronamente.
- Fornecer endpoints de status: GET /api/jobs/:jobId para checar progresso.
- Validar tamanho máximo de upload e usar presigned URLs para uploads diretos ao storage quando apropriado.

----

Exemplos rápidos (curl)

1) Iniciar upload (multipart):

curl -H "Authorization: Bearer $TOKEN" -F "file=@/path/to/audio.webm" -F "metadata={\"candidate\":{\"name\":\"João\"}}" https://api.exemplo.com/api/interviews/123/audio

2) Solicitar resumo:

curl -X POST -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d '{"transcription_id":"t1"}' https://api.exemplo.com/api/interviews/123/summarize

----

Se quiser, eu posso:
- Gerar um `docs/api.openapi.yaml` (OpenAPI 3.0) a partir dessas especificações.
- Implementar handlers mock (Express) para testes locais e um pequeno cliente WebSocket de exemplo para a extensão.
